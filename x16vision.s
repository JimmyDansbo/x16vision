.include "x16.inc"
.include "macros.inc"

.import __XVKIT_LOWRAM_SIZE__, __XVKITBSS_SIZE__, __XVKITBSS_LOAD__

X16VISION_VERSION = $0001

.segment "JUMPTABLE"
	jmp	xv_initialize	; $A000
	jmp	xv_setisr	; $A003
	jmp	xv_clearisr	; $A006

.segment "XVKITBSS"
_XV_BSS_START = *
; Lowram address provided by the user to copy ISR routine to.
lowram_addr:	.res 2
; Object handled by library are in a linked list, this points to the start of the list.
init_obj_bank:	.res 1
init_obj_addr:	.res 2

_XV_BSS_END = *

.segment "XVKITLIB"

;*****************************************************************************
; Enable the ISR routine, but first ensure that it jumps to the original
; interrupt routine upon exit
;=============================================================================
; Preserves X register
;*****************************************************************************
.proc	xv_setisr: near
	nop

	lda	#$EA		; NOP
	sta	xv_clearisr	; Ungate xv_clearisr
	lda	#$60		; RTS
	sta	xv_setisr	; Gate xv_setisr

	; Save ZP ptr to stack
	SAVE_PTR X16_PTR_0

	; Set ZP ptr to start of lowram isr
	lda	lowram_addr
	sta	X16_PTR_0
	lda	lowram_addr+1
	sta	X16_PTR_0+1
	; Set Y to offset of _old_isr
	ldy	#(_end_isr-_isr-2)

	; Save old interrupt vector
	lda	X16_Vector_IRQ
	sta	(X16_PTR_0),y
	iny
	lda	X16_Vector_IRQ+1
	sta	(X16_PTR_0),y

	; Restore ZP ptr from stack
	RESTORE_PTR X16_PTR_0

	; Tell VERA that we want VSYNC interrupts (should already be enabled)
	lda	Vera_Reg_IEN
	ora	#$01
	sta	Vera_Reg_IEN

	; Install new interrupt vector
	sei	; Disable interrupts
	lda	lowram_addr
	sta	X16_Vector_IRQ
	lda	lowram_addr+1
	sta	X16_Vector_IRQ+1
	cli	; Enable interrupts
	rts
.endproc

;*****************************************************************************
; Disable the ISR routine by reinstalling the original IRQ vector
;=============================================================================
; Preserves X register
;*****************************************************************************
.proc	xv_clearisr: near
	rts	; Gate

	lda	#$EA		; NOP
	sta	xv_setisr	; Ungate xv_setisr
	lda	#$60		; RTS
	sta	xv_clearisr	; Gate xv_clearisr

	; Save ZP ptr to stack
	SAVE_PTR X16_PTR_0

	; Set ZP ptr to start of lowram isr
	lda	lowram_addr
	sta	X16_PTR_0
	lda	lowram_addr+1
	sta	X16_PTR_0+1
	; Set Y to offset of _old_isr
	ldy	#(_end_isr-_isr-2)
	
	sei	; Disable interrupts
	lda	(X16_PTR_0),y
	sta	X16_Vector_IRQ
	iny
	lda	(X16_PTR_0),y
	sta	X16_Vector_IRQ+1
	cli	; Enable interrupts

	; Restore ZP ptr from stack
	RESTORE_PTR X16_PTR_0
	rts
.endproc

;*****************************************************************************
; Zeroes out variable space, copies ISR to lowram and ensures ISR loads 
; correct RAM bank before calling xv_tick to actually handle the interrupt.
;=============================================================================
; Arguments: A and X are low- and high-byte of lowram address reserved for
;            the x16vision library
;-----------------------------------------------------------------------------
; Preserves: X and Y
; Returns: (none)
;*****************************************************************************
.proc	xv_initialize: near
	phy	; Preserve Y
	tay	; Save low byte of lowram address in Y
	; Save ZP ptr to stack
	SAVE_PTR X16_PTR_0
	phy	; Save low byte of lowram on stack

	; Set ZP ptr to address of variables
	lda	#<__XVKITBSS_LOAD__
	sta	X16_PTR_0
	lda	#>__XVKITBSS_LOAD__
	sta	X16_PTR_0+1
	; Zero out variables
	lda	#0
	ldy	#<(__XVKITBSS_SIZE__-1)
@zloop:
	sta	(X16_PTR_0),y
	dey
	bpl	@zloop

	pla	; Restore low byte of lowram from stack
	; Save low byte of lowram address and write it to ZP ptr
	sta	lowram_addr
	sta	X16_PTR_0
	; Save high byte of lowram address and write it to ZP ptr
	stx	lowram_addr+1
	stx	X16_PTR_0+1
	; Save current RAM bank, this is where x16vision library is loaded
	lda	X16_RAMBank_Reg
	sta	ISRBANK

	; Copy ISR routine to low ram
	ldy	#(_end_isr-_isr-1) ; Size of ISR routine
@loop:
	lda	_isr,y
	sta	(X16_PTR_0),y
	dey
	bpl	@loop

	; Restore ZP ptr
	RESTORE_PTR X16_PTR_0
	ply	; Restore Y
	rts
.endproc

;*****************************************************************************
;=============================================================================
;*****************************************************************************
.proc	xv_tick: near
	rts
.endproc

.segment "XVKIT_LOWRAM"
;*****************************************************************************
; Ensures the interrupt was generated by VSYNC, otherwise it just calls the
; previous interrupt handler.
; If VSYNC generated the interrupt, the current RAM bank is saved, the RAM
; bank where x16vision library is installed is set and a jsr to xv_tick
; function is performed before continuing on to previous interrupt handler
;=============================================================================
; ROM has already preserved registers and previous interrupt handler should
; ensure they are restored. RAM bank is restored before call to original
; interrupt handler
;*****************************************************************************
_isr:
	; Check if interrupt is VSYNC
	lda	Vera_Reg_ISR
	and	#$01
	beq	_old_isr	; If not VSYNC, skip this ISR
	; Save current RAM bank
	lda	X16_RAMBank_Reg
	pha
	; Set RAM bank where x16vision library is loaded
	lda	#$FF	; Modified to correct bank = _isr+11
ISRBANK = * - 1
	sta	X16_RAMBank_Reg
	; Handle tick
	jsr	xv_tick
	; Restore RAM Bank
	pla
	sta	X16_RAMBank_Reg
_old_isr:
	jmp	$FFFF
_end_isr:

.assert __XVKIT_LOWRAM_SIZE__ <= 255, error, "XVKIT_LOWRAM segment may not be larger than 255 bytes"
.assert __XVKITBSS_SIZE__ <= 255, error, "XVKITBSS segment is larger than 255 bytes, check zeroing code"